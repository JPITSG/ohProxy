'use strict';

/**
 * Session Entropy Security Tests
 *
 * Tests for session ID and token security:
 * - Sufficient randomness/entropy
 * - No predictable patterns
 * - Proper length
 * - Safe character set
 */

const { describe, it } = require('node:test');
const assert = require('node:assert');
const crypto = require('crypto');

// Import session functions if available
let sessions;
try {
	sessions = require('../../sessions');
} catch {
	sessions = null;
}

describe('Session ID Generation', () => {
	it('generates UUID format session IDs', () => {
		if (!sessions) {
			// Test inline UUID generation
			const uuid = crypto.randomUUID();
			assert.ok(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid));
			return;
		}

		const sessionId = sessions.generateSessionId();
		// UUIDs are 36 chars with hyphens
		assert.ok(sessionId.length >= 32, 'Session ID should be at least 32 characters');
	});

	it('generates unique session IDs', () => {
		const generateId = sessions?.generateSessionId || crypto.randomUUID;
		const ids = new Set();
		const count = 1000;

		for (let i = 0; i < count; i++) {
			ids.add(generateId());
		}

		assert.strictEqual(ids.size, count, 'All session IDs should be unique');
	});

	it('session IDs have sufficient entropy (128+ bits)', () => {
		const generateId = sessions?.generateSessionId || crypto.randomUUID;
		const sessionId = generateId();

		// Remove hyphens and count hex chars
		const hexChars = sessionId.replace(/-/g, '');
		// Each hex char = 4 bits, need 32+ hex chars for 128 bits
		assert.ok(hexChars.length >= 32, `Session ID should have at least 128 bits of entropy, got ${hexChars.length * 4} bits`);
	});

	it('session IDs use only safe URL characters', () => {
		const generateId = sessions?.generateSessionId || crypto.randomUUID;

		for (let i = 0; i < 100; i++) {
			const sessionId = generateId();
			// Should only contain hex chars and hyphens (safe for URLs)
			assert.ok(
				/^[0-9a-f-]+$/i.test(sessionId),
				`Session ID contains unsafe characters: ${sessionId}`
			);
		}
	});

	it('session IDs are not sequential', () => {
		const generateId = sessions?.generateSessionId || crypto.randomUUID;

		const ids = [];
		for (let i = 0; i < 100; i++) {
			ids.push(generateId());
		}

		// Check that IDs don't have sequential numeric patterns
		for (let i = 1; i < ids.length; i++) {
			const prev = parseInt(ids[i - 1].replace(/-/g, ''), 16);
			const curr = parseInt(ids[i].replace(/-/g, ''), 16);
			// Difference should be large and random, not 1 or predictable
			const diff = Math.abs(curr - prev);
			assert.ok(diff > 1000000, 'Session IDs should not be sequential');
		}
	});
});

describe('CSRF Token Generation', () => {
	it('CSRF tokens have sufficient length (32+ bytes)', () => {
		const token = crypto.randomBytes(32).toString('hex');
		assert.strictEqual(token.length, 64, 'CSRF token should be 64 hex chars (32 bytes)');
	});

	it('CSRF tokens are cryptographically random', () => {
		const tokens = [];
		for (let i = 0; i < 100; i++) {
			tokens.push(crypto.randomBytes(32).toString('hex'));
		}

		// All should be unique
		const unique = new Set(tokens);
		assert.strictEqual(unique.size, 100, 'All CSRF tokens should be unique');
	});

	it('CSRF tokens use only hex characters', () => {
		for (let i = 0; i < 100; i++) {
			const token = crypto.randomBytes(32).toString('hex');
			assert.ok(/^[0-9a-f]+$/i.test(token), 'CSRF token should only contain hex chars');
		}
	});
});

describe('Cookie Key Entropy', () => {
	it('cookie key should be at least 32 bytes', () => {
		// Generate a secure cookie key
		const key = crypto.randomBytes(32).toString('base64');
		// 32 bytes = 256 bits of entropy
		const decoded = Buffer.from(key, 'base64');
		assert.ok(decoded.length >= 32, 'Cookie key should be at least 32 bytes');
	});

	it('cookie key should be cryptographically random', () => {
		const keys = [];
		for (let i = 0; i < 100; i++) {
			keys.push(crypto.randomBytes(32).toString('base64'));
		}

		const unique = new Set(keys);
		assert.strictEqual(unique.size, 100, 'All cookie keys should be unique');
	});
});

describe('Entropy Statistical Tests', () => {
	it('generated bytes have uniform distribution', () => {
		// Generate many random bytes and check distribution
		const byteCount = new Array(256).fill(0);
		const sampleSize = 25600; // 100 bytes per bucket expected

		const randomBytes = crypto.randomBytes(sampleSize);
		for (let i = 0; i < sampleSize; i++) {
			byteCount[randomBytes[i]]++;
		}

		// Chi-square test for uniformity
		const expected = sampleSize / 256;
		let chiSquare = 0;
		for (let i = 0; i < 256; i++) {
			const diff = byteCount[i] - expected;
			chiSquare += (diff * diff) / expected;
		}

		// For 255 degrees of freedom, chi-square should be < 310 for p=0.05
		// We use a more lenient threshold to avoid flaky tests
		assert.ok(chiSquare < 350, `Chi-square ${chiSquare} indicates non-uniform distribution`);
	});

	it('no repeated patterns in generated tokens', () => {
		const tokens = [];
		for (let i = 0; i < 1000; i++) {
			tokens.push(crypto.randomBytes(16).toString('hex'));
		}

		// Check for duplicates
		const unique = new Set(tokens);
		assert.strictEqual(unique.size, 1000, 'No duplicate tokens should exist');

		// Check for common prefixes (first 8 chars)
		const prefixes = new Set(tokens.map((t) => t.slice(0, 8)));
		// Should have at least 95% unique prefixes (allowing some collision)
		assert.ok(prefixes.size > 950, 'Tokens should not share common prefixes');
	});

	it('timestamp not embedded in session ID', () => {
		const generateId = sessions?.generateSessionId || crypto.randomUUID;

		// Generate IDs at different times
		const id1 = generateId();
		const id2 = generateId();

		// Convert to numbers and check they're not close to timestamps
		const now = Date.now();
		const id1Num = parseInt(id1.replace(/-/g, '').slice(0, 12), 16);
		const id2Num = parseInt(id2.replace(/-/g, '').slice(0, 12), 16);

		// IDs should not be close to current timestamp (within 1 hour in ms)
		const hourMs = 3600000;
		assert.ok(
			Math.abs(id1Num - now) > hourMs || Math.abs(id2Num - now) > hourMs,
			'Session ID should not embed predictable timestamp'
		);
	});
});

describe('Secure Random Number Generation', () => {
	it('crypto.randomBytes is used (not Math.random)', () => {
		// Verify crypto module is available and working
		const bytes = crypto.randomBytes(32);
		assert.ok(bytes instanceof Buffer);
		assert.strictEqual(bytes.length, 32);
	});

	it('randomUUID uses crypto-secure randomness', () => {
		// Node's crypto.randomUUID uses CSPRNG
		const uuid = crypto.randomUUID();
		assert.ok(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid));

		// Version 4 UUIDs use 122 bits of randomness
		// The '4' indicates version, and the variant bits are fixed
		assert.ok(uuid.charAt(14) === '4', 'UUID should be version 4');
		assert.ok('89ab'.includes(uuid.charAt(19).toLowerCase()), 'UUID should have correct variant');
	});

	it('randomBytes generates different values each call', () => {
		const samples = [];
		for (let i = 0; i < 100; i++) {
			samples.push(crypto.randomBytes(16).toString('hex'));
		}

		const unique = new Set(samples);
		assert.strictEqual(unique.size, 100, 'Each randomBytes call should produce unique output');
	});
});
